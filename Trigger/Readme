
This is where we keep our triggers

-- constraint 1

CREATE TRIGGER invoiceStatusTGR  
AFTER INSERT ON PAYMENT
REFERECING NEW ROW AS N
FOR EACH ROW
WHEN (
        (SELECT SUM(Product_unit_price * quantity)
         FROM ORDER_ITEM
         WHERE INVOICE.Number = PAYMENT.Invoice_number
         AND   ORDER_ITEM.Order_id = INVOICE.Order_id)
         =
        (SELECT SUM(Amount)
         FROM PAYMENT
         WHERE PAYMENT.Invoice_number = N.Invoice_number
        )
    ) 
BEGIN
    UPDATE INVOICE
    SET Status = 'paid'
    WHERE INVOICE.Id = N.Invoice_number
END;     



-- constraints 2

CREATE TRIGGER orderItemStatusTGR
AFTER INSERT ON SHIPMENT -
REFERENCING NEW ROW AS N
FOR EACH ROW
-- no need condition right?
BEGIN
    UPDATE ORDER_ITEM
    SET Status = 'shipped'
    WHERE ORDER_ITEM.Shipment_id = N.Id
END;

-- constraint 3

CREATE TRIGGER orderStatusTGR
AFTER UPDATE OF [Status] ON ORDER_ITEM
REFERENCING NEW ROW AS N
FOR EACH ROW
WHEN(
    NOT EXISTS(
        SELECT sequence_num
        FROM ORDER_ITEM
        WHERE ORDER_ITEM.Order_id = N.Order_id
        AND [Status] = 'processing'
    )
) 
BEGIN
    UPDATE ORDERS
    SET [Status] = 'completed'
    WHERE ORDERS.Id = N.Order_id
END;


-- constraint 4    --不会

CREATE TRIGGER limitePaymentTrg
BEFORE INSERT ON PAYMENT
REFERENCING NEW ROW AS N
FOR EACH ROW
WHEN(
    3 <=            
    SELECT COUNT(*)
    FROM INVOICE
    WHERE N.Invoice_number = INVOICE.Id
)
BEGIN
    IF (EXITST(
        SELECT
    ))
    THEN raise_exception('')
END;

-- constraint 5

CREATE TRIGGER canclePrecentTGR
BEFORE UPDATE OF [Status] ON ORDERS
REFERENCING NEW ROW AS N
FOR EACH ROW
WHEN(
    EXISTS(
        SELECT P.Id
        FROM ORDERS O, INVOICE I, PAYMENT P
        WHERE N.Id = I.Order_id AND I.Id = P.Invoice_number
    )
)
BEGIN
    IF(N.Status = "cancelled")
    THEN raise_exception('order can not be cancelled')
END;
